#lang "prelude.kl"

(import (shift "prelude.kl" 1))
(import "define-syntax-rule.kl")
(import "list.kl")
(import (shift "prim-syntax.kl" 1))

(define-macro (if-non-empty cond then else)
  -- Consider the following simpler implementation.
  --
  --     (pure `(let [it ,cond]
  --              (case it
  --                [(:: _ _)
  --                 ,then]
  --                [(nil)
  --                 ,else])))
  --
  -- Since the "it" variable is bound by code generated by the macro, hygiene
  -- dictates that it is only visible to the rest of the code generated by the
  -- macro. Thus, it would be visible in (case it ...), but not in the caller's
  -- (:: 0 it).
  --
  -- This is not what we want, so we override hygiene by constructing an
  -- identifier which inherits the lexical scope (and the source location) of
  -- one of the input syntax objects. This allows the identifier to be visible
  -- to the code in that input as well.
  (let [it
        (ident-syntax 'it cond)]
    (pure `(let [,it ,cond]
             (case ,it
               [(:: _ _)
                ,then]
               [(nil)
                ,else])))))

(example
  (if-non-empty (snoc (list 1 2 3) 4)
    (:: 0 it)
    (list 0)))
